<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Webhook Events</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    .filter-container {
      margin-bottom: 10px;
    }
    .filter-container label {
      margin-right: 10px;
    }
    .filter-container select {
      margin-right: 20px;
    }
    .back-button {
      margin-bottom: 20px;
      padding: 10px 20px;
      font-size: 1rem;
      background-color: #00BCD4;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .delete-selected-button {
      margin-left: 20px;
      padding: 8px 16px;
      font-size: 0.9rem;
      background-color: #e74c3c;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .delete-all-button {
      margin-left: 20px;
      padding: 8px 16px;
      font-size: 0.9rem;
      background-color: #c0392b;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    /* 테이블 고정 레이아웃 + row 높이 고정 & 스크롤 */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
      table-layout: fixed; /* 고정 레이아웃 */
    }
    thead th {
      background: #f0f0f0;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
      vertical-align: top;
      word-wrap: break-word;
    }
    /* 행 높이 고정 */
    tbody tr {
      height: 120px; /* 원하는 높이 */
    }
    /* 셀 내부가 넘칠 때 스크롤 */
    tbody td {
      overflow: auto; /* 스크롤바 표시 */
    }
  </style>
</head>
<body>
  <!-- Back to Admin 버튼 -->
  <button class="back-button" onclick="window.location.href='admin.html'">Back to Admin</button>

  <h1>Webhook Events</h1>

  <!-- 필터 & 삭제 버튼들 -->
  <div class="filter-container">
    <label for="nonOrderExtraTagFilter">Filter by Extra Tag (Non-Order):</label>
    <select id="nonOrderExtraTagFilter">
      <option value="all">All</option>
    </select>

    <label for="orderIdFilter">Filter by Order ID:</label>
    <select id="orderIdFilter">
      <option value="all">All</option>
    </select>

    <!-- 선택된 이벤트 일괄 삭제 -->
    <button class="delete-selected-button" id="deleteSelectedBtn">Delete Selected</button>

    <!-- 전체 이벤트 삭제 (모든 문서) -->
    <button class="delete-all-button" id="deleteAllBtn">Delete All</button>
  </div>

  <table id="eventsTable">
    <colgroup>
      <!-- 체크박스 -->
      <col style="width: 4%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
      <col style="width: 9%;">
    </colgroup>
    <thead>
      <tr>
        <th>
          <!-- 전체선택 체크박스 -->
          <input type="checkbox" id="selectAllCheckbox" />
        </th>
        <th>Received At</th>
        <th>Extra Tag</th>
        <th>Email</th>
        <th>Sent</th>
        <th>Opened</th>
        <th>Clicked</th>
        <th>Unsubscribed</th>
        <th>Complaints</th>
        <th>Bounce/Error</th>
        <th>Other Info</th>
        <th>ID</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    let allEvents = [];

    async function fetchEvents() {
      try {
        const response = await fetch('/api/webhook-events');
        const result = await response.json();

        if (!result.success) {
          console.error('Failed to fetch events:', result);
          return;
        }

        // 모든 이벤트
        allEvents = result.events;

        // 필터 옵션 업데이트
        updateFilterOptions(allEvents);

        // 테이블 최초 렌더링
        renderEvents();
      } catch (err) {
        console.error('Error fetching events:', err);
      }
    }

    function updateFilterOptions(events) {
      const nonOrderTagSet = new Set();
      const orderIdSet = new Set();

      events.forEach(event => {
        // Elastic Email에서 넘어오는 ExtraTag는 
        // event.data.merge_extratag OR event.data.extratag 등에 들어있을 수 있음
        const data = event.data || {};
        const tag = data.merge_extratag || data.extratag || 'N/A';

        // 주문번호는 generateDateTimeOrderId()로 만든 8자리 숫자라고 가정
        if (/^\d{8}$/.test(tag)) {
          orderIdSet.add(tag);
        } else {
          nonOrderTagSet.add(tag);
        }
      });

      // 드롭다운 DOM
      const nonOrderFilter = document.getElementById('nonOrderExtraTagFilter');
      const orderIdFilter = document.getElementById('orderIdFilter');

      // 기존 옵션 제거 (All 제외)
      while (nonOrderFilter.options.length > 1) {
        nonOrderFilter.remove(1);
      }
      while (orderIdFilter.options.length > 1) {
        orderIdFilter.remove(1);
      }

      // 채우기
      nonOrderTagSet.forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag;
        nonOrderFilter.appendChild(option);
      });

      orderIdSet.forEach(tag => {
        const option = document.createElement('option');
        option.value = tag;
        option.textContent = tag;
        orderIdFilter.appendChild(option);
      });
    }

    function renderEvents() {
      const nonOrderFilter = document.getElementById('nonOrderExtraTagFilter');
      const orderIdFilter = document.getElementById('orderIdFilter');

      const nonOrderSelected = nonOrderFilter.value;
      const orderSelected = orderIdFilter.value;

      // union(OR) 방식 필터링
      const filtered = allEvents.filter(event => {
        const data = event.data || {};
        const tag = data.merge_extratag || data.extratag || 'N/A';

        if (nonOrderSelected === 'all' && orderSelected === 'all') return true;
        if (nonOrderSelected !== 'all' && tag === nonOrderSelected) return true;
        if (orderSelected !== 'all' && tag === orderSelected) return true;
        return false;
      });

      const tbody = document.querySelector('#eventsTable tbody');
      tbody.innerHTML = '';

      filtered.forEach(event => {
        // DB에 저장된 _id
        const eventId = event._id;
        const data = event.data || {};

        // 구조분해
        const {
          to,
          from,
          status,
          messageid,
          merge_extratag,
          extratag,
          ...rest
        } = data;

        // 이벤트 타입
        const eventType = (event.eventType || '').toLowerCase();
        // 최종 Extra Tag
        const finalExtraTag = merge_extratag || extratag || 'N/A';

        const row = document.createElement('tr');

        // (1) 체크박스 셀
        const checkboxCell = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'row-checkbox';
        checkbox.value = eventId;
        checkboxCell.appendChild(checkbox);
        row.appendChild(checkboxCell);

        // (2) Received At
        const receivedCell = document.createElement('td');
        receivedCell.textContent = new Date(event.receivedAt).toLocaleString();
        row.appendChild(receivedCell);

        // (3) Extra Tag
        const tagCell = document.createElement('td');
        tagCell.textContent = finalExtraTag;
        row.appendChild(tagCell);

        // (4) Email (== "to")
        const emailCell = document.createElement('td');
        emailCell.textContent = to || 'N/A';
        row.appendChild(emailCell);

        // (5) Sent
        const sentCell = document.createElement('td');
        sentCell.textContent = (eventType === 'sent' || status === 'Sent') ? '✓' : '';
        row.appendChild(sentCell);

        // (6) Opened
        const openedCell = document.createElement('td');
        openedCell.textContent = (eventType === 'opened' || status === 'Opened') ? '✓' : '';
        row.appendChild(openedCell);

        // (7) Clicked
        const clickedCell = document.createElement('td');
        clickedCell.textContent = (eventType === 'clicked') ? '✓' : '';
        row.appendChild(clickedCell);

        // (8) Unsubscribed
        const unsubCell = document.createElement('td');
        unsubCell.textContent = (eventType === 'unsubscribed') ? '✓' : '';
        row.appendChild(unsubCell);

        // (9) Complaints (complaint, spamreport)
        const complaintCell = document.createElement('td');
        complaintCell.textContent = (eventType === 'complaint' || eventType === 'spamreport') ? '✓' : '';
        row.appendChild(complaintCell);

        // (10) Bounce/Error
        const bounceCell = document.createElement('td');
        bounceCell.textContent = ['bounce', 'error', 'failed'].includes(eventType) ? '✓' : '';
        row.appendChild(bounceCell);

        // (11) Other Info
        const otherInfoCell = document.createElement('td');
        // ...rest 내 JSON
        otherInfoCell.textContent = JSON.stringify(rest);
        row.appendChild(otherInfoCell);

        // (12) ID (messageid)
        const idCell = document.createElement('td');
        idCell.textContent = messageid || 'N/A';
        row.appendChild(idCell);

        tbody.appendChild(row);
      });
    }

    // 선택된 체크박스 삭제
    async function deleteSelectedEvents() {
      const checkboxes = document.querySelectorAll('.row-checkbox:checked');
      if (!checkboxes.length) {
        alert('No events selected for deletion.');
        return;
      }
      if (!confirm(`Delete ${checkboxes.length} selected event(s)?`)) return;

      const idsToDelete = Array.from(checkboxes).map(cb => cb.value);

      try {
        const resp = await fetch('/api/webhook-events/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ids: idsToDelete })
        });
        const result = await resp.json();
        if (result.success) {
          alert('Deleted successfully!');
          fetchEvents(); // 새로고침
        } else {
          alert('Failed to delete: ' + (result.message || 'Unknown error'));
        }
      } catch (err) {
        console.error('Error deleting selected events:', err);
      }
    }

    // 모든 이벤트 삭제
    async function deleteAllEvents() {
      if (!confirm('Delete ALL events in the database?')) return;

      // 서버 라우트에서 "ids" 없이 요청했을 때 모두 삭제하도록 구현할 수도 있음
      // 또는 서버에서 별도로 /delete-all 라우트 사용 가능
      try {
        const resp = await fetch('/api/webhook-events/delete', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ids: 'ALL' }) 
          // 예: 서버에서 if (ids === 'ALL') { await EmailEvent.deleteMany({}) }
        });
        const result = await resp.json();
        if (result.success) {
          alert('All events deleted successfully!');
          fetchEvents();
        } else {
          alert('Failed to delete all: ' + (result.message || 'Unknown error'));
        }
      } catch (err) {
        console.error('Error deleting all events:', err);
      }
    }

    // "Select All" 체크박스 핸들러
    function toggleSelectAll() {
      const selectAll = document.getElementById('selectAllCheckbox').checked;
      const checkboxes = document.querySelectorAll('.row-checkbox');
      checkboxes.forEach(cb => {
        cb.checked = selectAll;
      });
    }

    // 초기 바인딩
    document.getElementById('selectAllCheckbox').addEventListener('change', toggleSelectAll);
    document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelectedEvents);
    document.getElementById('deleteAllBtn').addEventListener('click', deleteAllEvents);

    // 드롭다운 변경 시 다시 렌더링
    document.getElementById('nonOrderExtraTagFilter').addEventListener('change', renderEvents);
    document.getElementById('orderIdFilter').addEventListener('change', renderEvents);

    // 페이지 로드 시 이벤트 데이터 조회
    fetchEvents();
  </script>
</body>
</html>